{
  "C++ CP Template": {
    "prefix": "head",
    "body": [
      "#include <bits/stdc++.h>",
      "",
      "#ifdef COOKIE_CHAN",
      "#include <debug.hpp>",
      "#else",
      "#define DEBUG(...)",
      "#endif",
      "",
      "typedef int64_t ll;",
      "typedef unsigned int64_t ull;",
      "typedef long double ld;",
      "",
      "#define int int64_t",
      "#define ff first",
      "#define ss second",
      "#define vt(...) vector< __VA_ARGS__ >",
      "#define sz(...) (int)(__VA_ARGS__).size()",
      "#define pii pair<int, int>",
      "#define pll pair<ll, ll>",
      "#define pb push_back",
      "#define mp make_pair",
      "#define mt make_tuple",
      "#define all(x) x.begin(), x.end()",
      "",
      "constexpr int M = 1000000007;",
      "constexpr int MONKE = 0;",
      "",
      "using namespace std;",
      "",
      "template <typename T1, typename T2>",
      "bool sort_by_second_greater(const pair<T1, T2>& a, const pair<T1, T2>& b) {",
      "\treturn (a.ss > b.ss);",
      "}",
      "",
      "int32_t main() {",
      "\t// unsync with C stream :)",
      "\tios_base::sync_with_stdio(MONKE);",
      "\t#ifndef COOKIE_CHAN",
      "\tcin.tie(0);",
      "\t#endif",
      "\t// todo",
      "\t$0",
      "\treturn MONKE;",
      "}"
    ],
    "description": "C++ CP template"
  },
  "Combination Fermat": {
    "prefix": "CombinationFermat",
    "body": [
      "int64_t power(int64_t num, int64_t exp, int64_t MOD = M) {",
      "\tint64_t res = 1LL;",
      "\twhile (exp) {",
      "\t\tif (exp & 1) res = (res * num) % MOD;",
      "\t\tnum = (num * num) % MOD;",
      "\t\texp >>= 1;",
      "\t}",
      "\treturn res;",
      "}",
      "",
      "constexpr int F_LIM = 1e6 + 5;",
      "vector<int64_t> factorial(F_LIM);",
      "int64_t PreFactorial(int64_t n) {",
      "\tfactorial[0] = 1;",
      "\tfactorial[1] = 1;",
      "\tfor (int i = 2; i < F_LIM; ++i) factorial[i] = (i * factorial[i - 1]) % M;",
      "}",
      "",
      "int64_t inv_factorial(int64_t n) {",
      "\tint64_t inv = factorial[n];",
      "\treturn power(inv, M - 2);",
      "}",
      "",
      "int64_t Combination(int64_t n, int64_t r) {",
      "\treturn (((factorial[n] * inv_factorial(r)) % M) * inv_factorial(n - r)) % M;",
      "}"
    ],
    "description": "Combination for big numbers when modded with a prime"
  },
  "Sieve of Erastosthenes": {
    "prefix": "sieve",
    "body": [
      "constexpr int PLIM = 1e6 + 5;",
      "vector<bool> Prime(PLIM, true);",
      "void Sieve() {",
      "\tfor (ll i = 2; i * i < PLIM; ++i) {",
      "\t\tif (!Prime[i]) continue;",
      "\t\tfor (ll j = i * i; j < PLIM; j += i) {",
      "\t\t\tPrime[j] = false;",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "Sieve of Eratosthenes"
  },
  "Segment Tree": {
    "prefix": "segment tree",
    "body": [
      "template <typename T>",
      "class SegmentTree {",
      "  private:",
      "\tint size;",
      "\tvector<T> tree;",
      "\tT operation(T a, T b);",
      "\tT OPERATIVE_IDENTITY;",
      "",
      "\tT segment_recurs(int l, int r, int x, int lx, int rx) {",
      "\t\tif (rx <= l || r <= lx) return OPERATIVE_IDENTITY;",
      "\t\tif (l <= lx && rx <= r) return tree[x];",
      "",
      "\t\tint m = (lx + rx) / 2;",
      "\t\tT g1 = segment_recurs(l, r, 2 * x + 1, lx, m);",
      "\t\tT g2 = segment_recurs(l, r, 2 * x + 2, m, rx);",
      "",
      "\t\treturn operation(g1, g2);",
      "\t}",
      "",
      "  public:",
      "\tSegmentTree(int n, T operative_identity) {",
      "\t\tsize = 1;",
      "\t\twhile (size < n) size <<= 1;",
      "\t\ttree = vector<T>(2 * size - 1, operative_identity);",
      "",
      "\t\tOPERATIVE_IDENTITY = operative_identity;",
      "\t}",
      "",
      "\tvoid build(vector<T> &init) {",
      "\t\tfor (int i = size - 1; i < size - 1 + (int)init.size(); ++i)",
      "\t\t\ttree[i] = init[i - size + 1];",
      "",
      "\t\tfor (int i = size - 2; i >= 0; --i) {",
      "\t\t\ttree[i] = operation(tree[2 * i + 1], tree[2 * i + 2]);",
      "\t\t}",
      "\t}",
      "",
      "\tvoid set(int i, T new_data) {",
      "\t\ti += size - 1;",
      "\t\ttree[i] = new_data;",
      "",
      "\t\tfor (int p = i - 1; p >= 0; --p) {",
      "\t\t\tp /= 2;",
      "\t\t\ttree[p] = operation(tree[2 * p + 1], tree[2 * p + 2]);",
      "\t\t}",
      "\t}",
      "",
      "\tT evaluate_range(int l, int r) { return segment_recurs(l, r, 0, 0, size); }",
      "};",
      "",
      "template <>",
      "$1 SegmentTree<$1>::operation($1 a, $1 b) {",
      "\t$2",
      "}"
    ],
    "description": "Segment Tree"
  },
  "cookie-debug": {
    "prefix": "cookie-debug",
    "body": [
      "#ifdef COOKIE_CHAN",
      "#include <debug.hpp>",
      "#else // COOKIE_CHAN",
      "#define DEBUG(...)",
      "#endif // COOKIE_CHAN"
    ],
    "description": "Cookie Debug is added"
  },
  "Usaco": {
    "prefix": "usaco",
    "body": [
      "freopen(\"$1.in\",  \"r\", stdin);",
      "freopen(\"$1.out\", \"w\", stdout);"
    ],
    "description": "Usaco input output format"
  },
  "Binary Exponentiation": {
    "prefix": "binary-exponentiation",
    "body": [
      "int64_t power(int64_t num, int64_t exp, int64_t MOD = M) {",
      "\tint64_t res = 1LL;",
      "\twhile (exp) {",
      "\t\tif (exp & 1) res = (res * num) % MOD;",
      "\t\tnum = (num * num) % MOD;",
      "\t\texp >>= 1;",
      "\t}",
      "\treturn res;",
      "}",
      ""
    ]
  },
  "test-case": {
    "prefix": "test-case",
    "body": ["int t;", "cin >> t;", "while (t--) {", "\t$0", "}"],
    "description": "test cases template"
  }
}
